// Floating Point Arithmetic
OPCODEREC (fadd, 63, 21,
    ppc_grab_regsfpdab(instr);

    snan_double_check(reg_a, reg_b);
    max_double_check(val_reg_a, val_reg_b);

    double ppc_dblresult64_d = val_reg_a + val_reg_b;
    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);
    ppc_update_fex();

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fsub, 63, 20,
    ppc_grab_regsfpdab(instr);

    snan_double_check(reg_a, reg_b);

    double ppc_dblresult64_d = val_reg_a - val_reg_b;

    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fdiv, 63, 18,
    ppc_grab_regsfpdab(instr);

    snan_double_check(reg_a, reg_b);

    double ppc_dblresult64_d = val_reg_a / val_reg_b;
    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODERECF (fmul, 63, 25,
    ppc_grab_regsfpdac(instr);

    snan_double_check(reg_a, reg_c);

    double ppc_dblresult64_d = val_reg_a * val_reg_c;
    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODERECF (fmadd, 63, 29,
    ppc_grab_regsfpdabc(instr);

    snan_double_check(reg_a, reg_c);
    snan_single_check(reg_b);

    double ppc_dblresult64_d = std::fma(val_reg_a, val_reg_c, val_reg_b);
    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODERECF (fmsub, 63, 28,
    ppc_grab_regsfpdabc(instr);

    snan_double_check(reg_a, reg_c);
    snan_single_check(reg_b);

    double ppc_dblresult64_d = std::fma(val_reg_a, val_reg_c, -val_reg_b);
    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODERECF (fnmadd, 63, 31,
    ppc_grab_regsfpdabc(instr);

    snan_double_check(reg_a, reg_c);
    snan_single_check(reg_b);

    double ppc_dblresult64_d = -std::fma(val_reg_a, val_reg_c, val_reg_b);
    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODERECF (fnmsub, 63, 30,
    ppc_grab_regsfpdabc(instr);

    snan_double_check(reg_a, reg_c);
    snan_single_check(reg_b);

    double ppc_dblresult64_d = -std::fma(val_reg_a, val_reg_c, -val_reg_b);
    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fadds, 59, 21,
    ppc_grab_regsfpdab(instr);

    snan_double_check(reg_a, reg_b);

    double ppc_dblresult64_d = (float)(val_reg_a + val_reg_b);
    ppc_store_sfpresult_flt(reg_d, ppc_dblresult64_d);

    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fsubs, 59, 20,
    ppc_grab_regsfpdab(instr);

    snan_double_check(reg_a, reg_b);

    double ppc_dblresult64_d = (float)(val_reg_a - val_reg_b);

    ppc_store_sfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fdivs, 59, 18,
    ppc_grab_regsfpdab(instr);

    snan_double_check(reg_a, reg_b);

    double ppc_dblresult64_d = (float)(val_reg_a / val_reg_b);
    ppc_store_sfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fmuls, 59, 25,
    ppc_grab_regsfpdac(instr);

    snan_double_check(reg_a, reg_c);

    double ppc_dblresult64_d = (float)(val_reg_a * val_reg_c);
    ppc_store_sfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fmadds, 59, 29,
    ppc_grab_regsfpdabc(instr);

    snan_double_check(reg_a, reg_c);
    snan_single_check(reg_b);

    double ppc_dblresult64_d = (float)std::fma(val_reg_a, val_reg_c, val_reg_b);
    ppc_store_sfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fmsubs, 59, 28,
    ppc_grab_regsfpdabc(instr);

    snan_double_check(reg_a, reg_c);
    snan_single_check(reg_b);

    double ppc_dblresult64_d = (float)std::fma(val_reg_a, val_reg_c, -val_reg_b);
    ppc_store_sfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fnmadds, 59, 31,
    ppc_grab_regsfpdabc(instr);

    snan_double_check(reg_a, reg_c);
    snan_single_check(reg_b);

    double ppc_dblresult64_d = -(float)std::fma(val_reg_a, val_reg_c, val_reg_b);
    ppc_store_sfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fnmsubs, 59, 30,
    ppc_grab_regsfpdabc(instr);

    snan_double_check(reg_a, reg_c);
    snan_single_check(reg_b);

    double ppc_dblresult64_d = -(float)std::fma(val_reg_a, val_reg_c, -val_reg_b);
    ppc_store_sfpresult_flt(reg_d, ppc_dblresult64_d);
    fpresult_update(ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fabs, 63, 264,
    ppc_grab_regsfpdb(instr);

    snan_single_check(reg_b);

    double ppc_dblresult64_d = abs(GET_FPR(reg_b));

    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC(fnabs, 63, 136,
    ppc_grab_regsfpdb(instr);

    snan_single_check(reg_b);

    double ppc_dblresult64_d = abs(GET_FPR(reg_b));
    ppc_dblresult64_d = -ppc_dblresult64_d;

    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC(fneg, 63, 40,
    ppc_grab_regsfpdb(instr);

    snan_single_check(reg_b);

    double ppc_dblresult64_d = -(GET_FPR(reg_b));

    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODERECF(fsel, 63, 23,
    ppc_grab_regsfpdabc(instr);

    double ppc_dblresult64_d = (val_reg_a >= -0.0) ? val_reg_c : val_reg_b;

    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC(fsqrt, 63, 22,
    ppc_grab_regsfpdb(instr);

    snan_single_check(reg_b);

    double testd2 = (double)(GET_FPR(reg_b));
    double ppc_dblresult64_d = std::sqrt(testd2);
    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC(fsqrts, 59, 22,
    ppc_grab_regsfpdb(instr);

    snan_single_check(reg_b);

    double testd2            = (double)(GET_FPR(reg_b));
    double ppc_dblresult64_d = (float)std::sqrt(testd2);
    ppc_store_sfpresult_flt(reg_d, ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (frsqrte, 63, 26,
    ppc_grab_regsfpdb(instr);
    snan_single_check(reg_b);

    double testd2            = (double)(GET_FPR(reg_b));
    double ppc_dblresult64_d = 1.0 / sqrt(testd2);
    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (frsp, 63, 12,
    ppc_grab_regsfpdb(instr);
    snan_single_check(reg_b);

    double ppc_dblresult64_d = (float)(GET_FPR(reg_b));
    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fres, 63, 24,
    ppc_grab_regsfpdb(instr);

    snan_single_check(reg_b);

    double start_num = GET_FPR(reg_b);
    double ppc_dblresult64_d = (float)(1.0 / start_num);
    ppc_store_dfpresult_flt(reg_d, ppc_dblresult64_d);

    if (start_num == 0.0) {
        ppc_state.fpscr |= FPSCR::ZX;
    }
    else if (std::isnan(start_num)) {
        ppc_state.fpscr |= FPSCR::VXSNAN;
    }
    else if (std::isinf(start_num)){
        ppc_state.fpscr &= 0xFFF9FFFF;
        ppc_state.fpscr |= FPSCR::VXSNAN;
    }

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (fctiw, 63, 14,
    round_to_int(instr, ppc_state.fpscr & 0x3, rec);
)

OPCODEREC (fctiwz, 63, 15,
    round_to_int(instr, 1, rec);
)

// Floating Point Store and Load

OPCODE (lfs, , 48,
    ppc_grab_regsfpdia(instr);
    uint32_t ea = int32_t(int16_t(instr));
    ea += (reg_a) ? val_reg_a : 0;
    uint32_t result              = mmu_read_vmem<uint32_t>(ea, instr);
    ppc_state.fpr[reg_d].dbl64_r = *(float*)(&result);
)

OPCODE (lfsu, , 49,
    ppc_grab_regsfpdia(instr);
    if (reg_a) {
        uint32_t ea = int32_t(int16_t(instr));
        ea += (reg_a) ? val_reg_a : 0;
        uint32_t result              = mmu_read_vmem<uint32_t>(ea, instr);
        ppc_state.fpr[reg_d].dbl64_r = *(float*)(&result);
        ppc_state.gpr[reg_a] = ea;
    } else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODE31 (lfsx, 31, 535,
    ppc_grab_regsfpdiab(instr);
    uint32_t ea = val_reg_b + (reg_a ? val_reg_a : 0);
    uint32_t result              = mmu_read_vmem<uint32_t>(ea, instr);
    ppc_state.fpr[reg_d].dbl64_r = *(float*)(&result);
)

OPCODE31 (lfsux, 31, 567,
    ppc_grab_regsfpdiab(instr);
    if (reg_a) {
        uint32_t ea = val_reg_a + val_reg_b;
        uint32_t result              = mmu_read_vmem<uint32_t>(ea, instr);
        ppc_state.fpr[reg_d].dbl64_r = *(float*)(&result);
        ppc_state.gpr[reg_a] = ea;
    } else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODE (lfd, , 50,
    ppc_grab_regsfpdia(instr);
    uint32_t ea = int32_t(int16_t(instr));
    ea += (reg_a) ? val_reg_a : 0;
    uint64_t ppc_result64_d = mmu_read_vmem<uint64_t>(ea, instr);
    ppc_store_dfpresult_int(reg_d, ppc_result64_d);
)

OPCODE (lfdu, , 51,
    ppc_grab_regsfpdia(instr);
    if (reg_a != 0) {
        uint32_t ea = int32_t(int16_t(instr));
        ea += val_reg_a;
        uint64_t ppc_result64_d = mmu_read_vmem<uint64_t>(ea, instr);
        ppc_store_dfpresult_int(reg_d, ppc_result64_d);
        ppc_state.gpr[reg_a] = ea;
    } else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODE31 (lfdx, 31, 599,
    ppc_grab_regsfpdiab(instr);
    uint32_t ea = val_reg_b + (reg_a ? val_reg_a : 0);
    uint64_t ppc_result64_d = mmu_read_vmem<uint64_t>(ea, instr);
    ppc_store_dfpresult_int(reg_d, ppc_result64_d);
)

OPCODE31 (lfdux, 31, 631,
    ppc_grab_regsfpdiab(instr);
    if (reg_a) {
        uint32_t ea = val_reg_a + val_reg_b;
        uint64_t ppc_result64_d = mmu_read_vmem<uint64_t>(ea, instr);
        ppc_store_dfpresult_int(reg_d, ppc_result64_d);
        ppc_state.gpr[reg_a] = ea;
    } else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODE (stfs, , 52,
    ppc_grab_regsfpsia(instr);
    uint32_t ea = int32_t(int16_t(instr));
    ea += (reg_a) ? val_reg_a : 0;
    float result = float(ppc_state.fpr[reg_s].dbl64_r);
    mmu_write_vmem<uint32_t>(ea, instr, *(uint32_t*)(&result));
)

OPCODE (stfsu, , 53,
    ppc_grab_regsfpsia(instr);
    if (reg_a != 0) {
        uint32_t ea = int32_t(int16_t(instr));
        ea += val_reg_a;
        float result = float(ppc_state.fpr[reg_s].dbl64_r);
        mmu_write_vmem<uint32_t>(ea, instr, *(uint32_t*)(&result));
        ppc_state.gpr[reg_a] = ea;
    } else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODE31 (stfsx, 31, 663,
    ppc_grab_regsfpsiab(instr);
    uint32_t ea = val_reg_b + (reg_a ? val_reg_a : 0);
    float result = float(ppc_state.fpr[reg_s].dbl64_r);
    mmu_write_vmem<uint32_t>(ea, instr, *(uint32_t*)(&result));
)

OPCODE31 (stfsux, 31, 695,
    ppc_grab_regsfpsiab(instr);
    if (reg_a) {
        uint32_t ea = val_reg_a + val_reg_b;
        float result = float(ppc_state.fpr[reg_s].dbl64_r);
        mmu_write_vmem<uint32_t>(ea, instr, *(uint32_t*)(&result));
        ppc_state.gpr[reg_a] = ea;
    } else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODE (stfd, , 54,
    ppc_grab_regsfpsia(instr);
    uint32_t ea = int32_t(int16_t(instr));
    ea += reg_a ? val_reg_a : 0;
    mmu_write_vmem<uint64_t>(ea, instr, ppc_state.fpr[reg_s].int64_r);
)

OPCODE (stfdu, , 55,
    ppc_grab_regsfpsia(instr);
    if (reg_a != 0) {
        uint32_t ea = int32_t(int16_t(instr));
        ea += val_reg_a;
        mmu_write_vmem<uint64_t>(ea, instr, ppc_state.fpr[reg_s].int64_r);
        ppc_state.gpr[reg_a] = ea;
    } else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODE31 (stfdx, 31, 727,
    ppc_grab_regsfpsiab(instr);
    uint32_t ea = val_reg_b + (reg_a ? val_reg_a : 0);
    mmu_write_vmem<uint64_t>(ea, instr, ppc_state.fpr[reg_s].int64_r);
)

OPCODE31 (stfdux, 31, 759,
    ppc_grab_regsfpsiab(instr);
    if (reg_a != 0) {
        uint32_t ea = val_reg_a + val_reg_b;
        mmu_write_vmem<uint64_t>(ea, instr, ppc_state.fpr[reg_s].int64_r);
        ppc_state.gpr[reg_a] = ea;
    } else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODE31 (stfiwx, 31, 983,
    ppc_grab_regsfpsiab(instr);
    uint32_t ea = val_reg_b + (reg_a ? val_reg_a : 0);
    mmu_write_vmem<uint32_t>(ea, instr, uint32_t(ppc_state.fpr[reg_s].int64_r));
)

// Floating Point Register Transfer

OPCODEREC (fmr, 63, 72,
    ppc_grab_regsfpdb(instr);
    ppc_state.fpr[reg_d].dbl64_r = ppc_state.fpr[reg_b].dbl64_r;

    if (rec)
        ppc_update_cr1();
)

OPCODE601REC (mffs, 63, 583,
    int reg_d = (instr >> 21) & 31;

    ppc_state.fpr[reg_d].int64_r = uint64_t(ppc_state.fpscr) | (for601 ? 0xFFFFFFFF00000000ULL : 0xFFF8000000000000ULL);

    if (rec)
        ppc_update_cr1();
)

OPCODEREC (mtfsf, 63, 711,
    ppc_grab_mtfsf(instr);

    uint32_t cr_mask = 0;

    if (fm == 0xFFU) {    // the fast case
        cr_mask = 0xFFFFFFFFUL;
    }
    else { // the slow case
        if (fm & 0x80) cr_mask |= 0xF0000000UL;
        if (fm & 0x40) cr_mask |= 0x0F000000UL;
        if (fm & 0x20) cr_mask |= 0x00F00000UL;
        if (fm & 0x10) cr_mask |= 0x000F0000UL;
        if (fm & 0x08) cr_mask |= 0x0000F000UL;
        if (fm & 0x04) cr_mask |= 0x00000F00UL;
        if (fm & 0x02) cr_mask |= 0x000000F0UL;
        if (fm & 0x01) cr_mask |= 0x0000000FUL;
    }

    // ensure neither FEX nor VX will be changed
    cr_mask &= ~(FPSCR::FEX | FPSCR::VX);

    // copy FPR[reg_b] to FPSCR under control of cr_mask
    ppc_state.fpscr = (ppc_state.fpscr & ~cr_mask) | (ppc_state.fpr[reg_b].int64_r & cr_mask);

    if (rec) {
        ppc_update_cr1();
    }
)

OPCODEREC (mtfsfi, 63, 134,
    ppc_grab_mtfsfi(instr);

    // prepare field mask and ensure that neither FEX nor VX will be changed
    uint32_t mask = (0xF0000000UL >> crf_d) & ~(FPSCR::FEX | FPSCR::VX);

    // copy imm to FPSCR[crf_d] under control of the field mask
    ppc_state.fpscr = (ppc_state.fpscr & ~mask) | ((imm >> crf_d) & mask);

    // Update FEX and VX according to the "usual rule"
    ppc_update_vx();
    ppc_update_fex();

    if (rec) { 
        ppc_update_cr1();
    }
)

OPCODE31 (mtfsb0, 63, 70,
    int crf_d = (instr >> 21) & 0x1F;
    if (!crf_d || (crf_d > 2)) { // FEX and VX can't be explicitly cleared
        ppc_state.fpscr &= ~(0x80000000UL >> crf_d);
    }

    if (rec)
        ppc_update_cr1();
)

OPCODE31 (mtfsb1, 63, 38,
    ppc_grab_crfd(instr);
    if (!crf_d || (crf_d > 2)) { // FEX and VX can't be explicitly set
        ppc_state.fpscr |= (0x80000000UL >> crf_d);
    }

    if (rec) { 
        ppc_update_cr1();
    }
)

OPCODE31 (mcrfs, 63, 64,
    ppc_grab_crfds(instr);
    ppc_state.cr = (
        (ppc_state.cr & ~(0xF0000000UL >> crf_d)) |
        (((ppc_state.fpscr << crf_s) & 0xF0000000UL) >> crf_d)
    );
    ppc_state.fpscr &= ~((0xF0000000UL >> crf_s) & (
        // keep only the FPSCR bits that can be explicitly cleared
        FPSCR::FX | FPSCR::OX |
        FPSCR::UX | FPSCR::ZX | FPSCR::XX | FPSCR::VXSNAN |
        FPSCR::VXISI | FPSCR::VXIDI | FPSCR::VXZDZ | FPSCR::VXIMZ |
        FPSCR::VXVC |
        FPSCR::VXSOFT | FPSCR::VXSQRT | FPSCR::VXCVI
    ));
)

// Floating Point Comparisons

OPCODE31 (fcmpo, 63, 32,
    ppc_grab_regsfpsab(instr);

    uint32_t cmp_c = 0;

    if (std::isnan(db_test_a) || std::isnan(db_test_b)) {
        cmp_c |= CRx_bit::CR_SO;
        ppc_state.fpscr |= FX | VX;
        if (check_snan(reg_a) || check_snan(reg_b)) {
            ppc_state.fpscr |= VXSNAN;
        }
        if (!(ppc_state.fpscr & FEX) || check_qnan(reg_a) || check_qnan(reg_b)) {
            ppc_state.fpscr |= VXVC;
        }
    }
    else if (db_test_a < db_test_b) {
        cmp_c |= CRx_bit::CR_LT;
    }
    else if (db_test_a > db_test_b) {
        cmp_c |= CRx_bit::CR_GT;
    }
    else {
        cmp_c |= CRx_bit::CR_EQ;
    }

    ppc_state.fpscr &= ~VE; //kludge to pass tests
    ppc_state.fpscr = (ppc_state.fpscr & ~FPSCR::FPCC_MASK) | (cmp_c >> 16); // update FPCC
    ppc_state.cr = ((ppc_state.cr & ~(0xF0000000 >> crf_d)) | (cmp_c >> crf_d));

)

OPCODE (fcmpu, 63, 0,
    ppc_grab_regsfpsab(instr);

    uint32_t cmp_c = 0;

    if (std::isnan(db_test_a) || std::isnan(db_test_b)) {
        cmp_c |= CRx_bit::CR_SO;
        if (check_snan(reg_a) || check_snan(reg_b)) {
            ppc_state.fpscr |= FX | VX | VXSNAN;
        }
    }
    else if (db_test_a < db_test_b) {
        cmp_c |= CRx_bit::CR_LT;
    }
    else if (db_test_a > db_test_b) {
        cmp_c |= CRx_bit::CR_GT;
    }
    else {
        cmp_c |= CRx_bit::CR_EQ;
    }

    ppc_state.fpscr &= ~VE; //kludge to pass tests
    ppc_state.fpscr = (ppc_state.fpscr & ~FPSCR::FPCC_MASK) | (cmp_c >> 16); // update FPCC
    ppc_state.cr    = ((ppc_state.cr & ~(0xF0000000UL >> crf_d)) | (cmp_c >> crf_d));

)
