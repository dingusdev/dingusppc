POWEROPCODEOVREC (abs, 31, 360,
    uint32_t ppc_result_d;
    ppc_grab_regsda(instr);
    if (ppc_result_a == 0x80000000) {
        ppc_result_d = ppc_result_a;
        if (ov)
            ppc_set_xer(XER::SO | XER::OV);
    } else {
        ppc_result_d = (int32_t(ppc_result_a) < 0) ? -ppc_result_a : ppc_result_a;
        if (ov)
            ppc_unset_xer(XER::OV);
    }

    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_state.gpr[reg_d] = ppc_result_d;
)

POWEROPCODE31 (clcs, 31, 531,
    ppc_grab_da(instr); 
    uint32_t ppc_result_d = 0;

    switch (reg_a) {
    case 12: //instruction cache line size
    case 13: //data cache line size
    case 14: //minimum line size
    case 15: //maximum line size
    default: 
        ppc_result_d = is_601 ? 64 :     32; break;
    case  7:
    case 23: 
        ppc_result_d = is_601 ? 64 :      0; break;
    case  8:
    case  9:
    case 24:
    case 25: 
        ppc_result_d = is_601 ? 64 :      4; break;
    case 10:
    case 11:
    case 26:
    case 27: 
        ppc_result_d = is_601 ? 64 : 0x4000; break;
    }

    ppc_state.gpr[reg_d] = ppc_result_d;
)

POWEROPCODEOVREC (div, 31, 331,
    uint32_t ppc_result_d;
    ppc_grab_regsdab(instr);

    int64_t dividend = (uint64_t(ppc_result_a) << 32) | ppc_state.spr[SPR::MQ];
    int32_t divisor = ppc_result_b;
    int64_t quotient;
    int32_t remainder;

    if (dividend == -0x80000000 && divisor == -1) {
        remainder = 0;
        ppc_result_d = 0x80000000U; // -2^31 aka INT32_MIN
        if (ov)
            ppc_set_xer(XER::SO | XER::OV);
    } else if (!divisor) {
        remainder = 0;
        ppc_result_d = 0x80000000U; // -2^31 aka INT32_MIN
        if (ov)
            ppc_set_xer(XER::SO | XER::OV);
    } else {
        quotient = dividend / divisor;
        remainder = dividend % divisor;
        ppc_result_d = uint32_t(quotient);
        if (ov) {
            if (((quotient >> 31) + 1) & ~1) {
                ppc_set_xer(XER::SO | XER::OV);
            } else {
                ppc_unset_xer(XER::OV);
            }
        }
    }

    if (rec)
        ppc_changecrf0(remainder);

    ppc_state.gpr[reg_d] = ppc_result_d;
    power_store_mq(remainder);
)

POWEROPCODEOVREC (divs, 31, 363,
    uint32_t ppc_result_d;
    int32_t remainder;
    ppc_grab_regsdab(instr);

    if (!ppc_result_b) { // handle the "anything / 0" case
        ppc_result_d = -1;
        remainder = ppc_result_a;
        if (ov)
            ppc_set_xer(XER::SO | XER::OV);
    } else if (ppc_result_a == 0x80000000U && ppc_result_b == 0xFFFFFFFFU) {
        ppc_result_d = 0x80000000U;
        remainder = 0;
        if (ov)
            ppc_set_xer(XER::SO | XER::OV);
    } else { // normal signed devision
        ppc_result_d = int32_t(ppc_result_a) / int32_t(ppc_result_b);
        remainder = (int32_t(ppc_result_a) % int32_t(ppc_result_b));
        if (ov)
            ppc_unset_xer(XER::OV);
    }
    if (rec)
        ppc_changecrf0(remainder);

    ppc_state.gpr[reg_d] = ppc_result_d;
    power_store_mq(remainder);;
)

POWEROPCODEOVREC (doz, 31, 264,
    ppc_grab_regsdab(instr);
    uint32_t ppc_result_d = (int32_t(ppc_result_a) < int32_t(ppc_result_b)) ?
        ppc_result_b - ppc_result_a : 0;

    if (ov) {
        if (int32_t(ppc_result_d) < 0) {
            ppc_set_xer(XER::SO | XER::OV);
        } else {
            ppc_unset_xer(XER::OV);
        }
    }
    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_state.gpr[reg_d] = ppc_result_d;
)

POWEROPCODE (dozi, , 9,
    ppc_grab_regsdasimm(instr); 
    uint32_t ppc_result_d = 0;
    if (((int32_t)ppc_result_a) > simm) {
        ppc_result_d = 0;
    } 
    else {
        ppc_result_d = simm - ppc_result_a;
    }
    ppc_state.gpr[reg_d] = ppc_result_d;
)

POWEROPCODEREC (lscbx, 31, 277,
    ppc_grab_regsdab(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);

    uint32_t bytes_to_load = (ppc_state.spr[SPR::XER] & 0x7F);
    uint32_t bytes_remaining = bytes_to_load;
    uint8_t  matching_byte = (uint8_t)(ppc_state.spr[SPR::XER] >> 8);
    uint32_t ppc_result_d = 0;
    bool     is_match = false;

    // for storing each byte
    uint8_t  shift_amount = 24;

    while (bytes_remaining > 0) {
        uint8_t return_value = mmu_read_vmem<uint8_t>(ea, instr);

        ppc_result_d |= return_value << shift_amount;
        if (!shift_amount) {
            if (reg_d != reg_a && reg_d != reg_b) {
                ppc_state.gpr[reg_d] = ppc_result_d;
            }
            reg_d        = (reg_d + 1) & 0x1F;
            ppc_result_d = 0;
            shift_amount = 24;
        } else {
            shift_amount -= 8;
        }

        ea++;
        bytes_remaining--;

        if (return_value == matching_byte) {
            is_match = true;
            break;
        }
    }

    // store partially loaded register if any
    if (shift_amount != 24 && reg_d != reg_a && reg_d != reg_b) {
        ppc_state.gpr[reg_d] = ppc_result_d;
    }

    ppc_state.spr[SPR::XER] = (ppc_state.spr[SPR::XER] & ~0x7F) | (bytes_to_load - bytes_remaining);

    if (rec) { \
        ppc_state.cr = \
            (ppc_state.cr & 0x0FFFFFFFUL) | \
            (is_match ? CRx_bit::CR_EQ : 0) | \
            ((ppc_state.spr[SPR::XER] & XER::SO) >> 3);
    }
)

POWEROPCODEREC (maskg, 31, 29,
    ppc_grab_regssab(instr);
    uint32_t mask_start  = ppc_result_d & 0x1F;
    uint32_t mask_end    = ppc_result_b & 0x1F;
    uint32_t insert_mask = 0;

    if (mask_start < (mask_end + 1)) {
        insert_mask = power_rot_mask(mask_start, mask_end);
    }
    else if (mask_start == (mask_end + 1)) {
        insert_mask = 0xFFFFFFFF;
    }
    else {
        insert_mask = ~(power_rot_mask(mask_end + 1, mask_start - 1));
    }

    ppc_result_a = insert_mask;

    if (rec){
        ppc_changecrf0(ppc_result_a);
    }

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (maskir, 31, 541,
    ppc_grab_regssab(instr);
    ppc_result_a = (ppc_result_a & ~ppc_result_b) | (ppc_result_d & ppc_result_b);

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEOVREC (mul, 31, 107,
    ppc_grab_regsdab(instr);
    int64_t product        = int64_t(int32_t(ppc_result_a)) * int32_t(ppc_result_b);
    uint32_t ppc_result_d  = uint32_t(uint64_t(product) >> 32);
    ppc_state.spr[SPR::MQ] = uint32_t(product);

    if (ov) {
        if (uint64_t(product >> 31) + 1 & ~1) {
            ppc_set_xer(XER::SO | XER::OV);
        } else {
            ppc_unset_xer(XER::OV);
        }
    }
    if (rec)
        ppc_changecrf0(uint32_t(product));
    ppc_state.gpr[reg_d] = ppc_result_d;
)

POWEROPCODEOVREC (nabs, 31, 488,
    ppc_grab_regsda(instr);
    uint32_t ppc_result_d = (int32_t(ppc_result_a) < 0) ? ppc_result_a : -ppc_result_a;

    if (ov)
        ppc_unset_xer(XER::OV);
    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_state.gpr[reg_d] = ppc_result_d;
)

POWEROPCODE (rlmi, , 22,
    ppc_grab_regssab(instr);
    unsigned rot_mb      = (instr >> 6) & 0x1F;
    unsigned rot_me      = (instr >> 1) & 0x1F;
    unsigned rot_sh      = ppc_result_b & 0x1F;

    uint32_t r           = ((ppc_result_d << rot_sh) | (ppc_result_d >> (32 - rot_sh)));
    uint32_t mask        = power_rot_mask(rot_mb, rot_me);

    ppc_result_a         = ((r & mask) | (ppc_result_a & ~mask));

    if ((instr & 0x01) == 1)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (rrib, 31, 537,
    ppc_grab_regssab(instr);
    unsigned rot_sh = ppc_result_b & 0x1F;

    if (int32_t(ppc_result_d) < 0) {
        ppc_result_a |= (0x80000000U >> rot_sh);
    } else {
        ppc_result_a &= ~(0x80000000U >> rot_sh);
    }

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (sle, 31, 153,
    ppc_grab_regssab(instr);
    unsigned rot_sh = ppc_result_b & 0x1F;

    ppc_result_a           = ppc_result_d << rot_sh;
    ppc_state.spr[SPR::MQ] = ((ppc_result_d << rot_sh) | (ppc_result_d >> (32 - rot_sh)));

    ppc_state.gpr[reg_a] = ppc_result_a;

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (sleq, 31, 217,
    ppc_grab_regssab(instr);
    unsigned rot_sh = ppc_result_b & 0x1F;
    uint32_t r      = ((ppc_result_d << rot_sh) | (ppc_result_d >> (32 - rot_sh)));
    uint32_t mask   = power_rot_mask(0, 31 - rot_sh);

    ppc_result_a           = ((r & mask) | (ppc_state.spr[SPR::MQ] & ~mask));
    ppc_state.spr[SPR::MQ] = r;

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (sliq, 31, 184,
    ppc_grab_regssash(instr);

    ppc_result_a           = ppc_result_d << rot_sh;
    ppc_state.spr[SPR::MQ] = ((ppc_result_d << rot_sh) | (ppc_result_d >> (32 - rot_sh)));

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (slliq, 31, 248,
    ppc_grab_regssash(instr);
    uint32_t r      = ((ppc_result_d << rot_sh) | (ppc_result_d >> (32 - rot_sh)));
    uint32_t mask   = power_rot_mask(0, 31 - rot_sh);

    ppc_result_a           = ((r & mask) | (ppc_state.spr[SPR::MQ] & ~mask));
    ppc_state.spr[SPR::MQ] = r;

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (sllq, 31, 216,
    ppc_grab_regssab(instr);
    unsigned rot_sh = ppc_result_b & 0x1F;

    if (ppc_result_b & 0x20) {
        ppc_result_a = ppc_state.spr[SPR::MQ] & (-1U << rot_sh);
    } else {
        ppc_result_a = ((ppc_result_d << rot_sh) | (ppc_state.spr[SPR::MQ] & ((1 << rot_sh) - 1)));
    }

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (slq, 31, 152,
    ppc_grab_regssab(instr);
    unsigned rot_sh = ppc_result_b & 0x1F;

    if (ppc_result_b & 0x20) {
        ppc_result_a = 0;
    } else {
        ppc_result_a = ppc_result_d << rot_sh;
    }

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.spr[SPR::MQ] = ((ppc_result_d << rot_sh) | (ppc_result_d >> (32 - rot_sh)));
    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (sraiq, 31, 952,
    ppc_grab_regssash(instr);
    uint32_t mask          = (1 << rot_sh) - 1;
    ppc_result_a           = (int32_t)ppc_result_d >> rot_sh;
    ppc_state.spr[SPR::MQ] = (ppc_result_d >> rot_sh) | (ppc_result_d << (32 - rot_sh));

    if ((int32_t(ppc_result_d) < 0) && (ppc_result_d & mask)) {
        ppc_state.spr[SPR::XER] |= XER::CA;
    } else {
        ppc_state.spr[SPR::XER] &= ~XER::CA;
    }

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (sraq, 31, 920,
    ppc_grab_regssab(instr);
    unsigned rot_sh        = ppc_result_b & 0x1F;
    uint32_t mask          = (ppc_result_b & 0x20) ? -1 : (1 << rot_sh) - 1;
    ppc_result_a           = (int32_t)ppc_result_d >> ((ppc_result_b & 0x20) ? 31 : rot_sh);
    ppc_state.spr[SPR::MQ] = ((ppc_result_d << rot_sh) | (ppc_result_d >> (32 - rot_sh)));

    if ((int32_t(ppc_result_d) < 0) && (ppc_result_d & mask)) {
        ppc_state.spr[SPR::XER] |= XER::CA;
    } else {
        ppc_state.spr[SPR::XER] &= ~XER::CA;
    }

    ppc_state.spr[SPR::MQ] = (ppc_result_d >> rot_sh) | (ppc_result_d << (32 - rot_sh));

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (sre, 31, 665,
    ppc_grab_regssab(instr);

    unsigned rot_sh = ppc_result_b & 0x1F;
    ppc_result_a    = ppc_result_d >> rot_sh;

    ppc_state.spr[SPR::MQ] = (ppc_result_d >> rot_sh) | (ppc_result_d << (32 - rot_sh));

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (srea, 31, 921,
    ppc_grab_regssab(instr);
    unsigned rot_sh        = ppc_result_b & 0x1F;
    ppc_result_a           = (int32_t)ppc_result_d >> rot_sh;
    uint32_t r             = ((ppc_result_d >> rot_sh) | (ppc_result_d << (32 - rot_sh)));
    uint32_t mask          = -1U >> rot_sh;

    if ((int32_t(ppc_result_d) < 0) && (r & ~mask)) {
        ppc_state.spr[SPR::XER] |= XER::CA;
    } else {
        ppc_state.spr[SPR::XER] &= ~XER::CA;
    }

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
    ppc_state.spr[SPR::MQ] = r;
)

POWEROPCODEREC (sreq, 31, 729,
    ppc_grab_regssab(instr);
    unsigned rot_sh = ppc_result_b & 0x1F;
    uint32_t mask   = -1U >> rot_sh;

    ppc_result_a           = (ppc_result_d >> rot_sh) | (ppc_state.spr[SPR::MQ] & ~mask);
    ppc_state.spr[SPR::MQ] = (ppc_result_d >> rot_sh) | (ppc_result_d << (32 - rot_sh));

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (sriq, 31, 696,
    ppc_grab_regssash(instr);
    ppc_result_a           = ppc_result_d >> rot_sh;
    ppc_state.spr[SPR::MQ] = (ppc_result_d >> rot_sh) | (ppc_result_d << (32 - rot_sh));

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (srliq, 31, 760,
    ppc_grab_regssash(instr);
    uint32_t r      = (ppc_result_d >> rot_sh) | (ppc_result_d << (32 - rot_sh));
    unsigned mask   = power_rot_mask(rot_sh, 31);

    ppc_result_a           = ((r & mask) | (ppc_state.spr[SPR::MQ] & ~mask));
    ppc_state.spr[SPR::MQ] = r;

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (srlq, 31, 728,
    ppc_grab_regssab(instr);
    unsigned rot_sh = ppc_result_b & 0x1F;
    uint32_t r      = (ppc_result_d >> rot_sh) | (ppc_result_d << (32 - rot_sh));
    unsigned mask   = power_rot_mask(rot_sh, 31);

    if (ppc_result_b & 0x20) {
        ppc_result_a = (ppc_state.spr[SPR::MQ] & mask);
    } else {
        ppc_result_a = ((r & mask) | (ppc_state.spr[SPR::MQ] & ~mask));
    }

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)

POWEROPCODEREC (srq, 31, 664,
    ppc_grab_regssab(instr);
    unsigned rot_sh = ppc_result_b & 0x1F;

    if (ppc_result_b & 0x20) {
        ppc_result_a = 0;
    } else {
        ppc_result_a = ppc_result_d >> rot_sh;
    }

    ppc_state.spr[SPR::MQ] = (ppc_result_d >> rot_sh) | (ppc_result_d << (32 - rot_sh));

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_state.gpr[reg_a] = ppc_result_a;
)
