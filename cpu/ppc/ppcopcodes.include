OPCODESHIFT (addi, , 14,
    ppc_grab_regsdasimm(instr);
    if (shift)
        ppc_state.gpr[reg_d] = (reg_a == 0) ? (simm << 16) : (ppc_result_a + (simm << 16));
    else
        ppc_state.gpr[reg_d] = (reg_a == 0) ? simm : (ppc_result_a + simm);
)

OPCODEREC (addic, , 6,
    ppc_grab_regsdasimm(instr);
    uint32_t ppc_result_d = (ppc_result_a + simm);
    ppc_carry(ppc_result_a, ppc_result_d);
    if (rec)
        ppc_changecrf0(ppc_result_d);
    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODECARRY (add, 31, 10,
    ppc_grab_regsdab(instr);
    uint32_t ppc_result_d = ppc_result_a + ppc_result_b;

    if (carry)
        ppc_carry(ppc_result_a, ppc_result_d);
    if (ov)
        ppc_setsoov(ppc_result_a, ~ppc_result_b, ppc_result_d);
    if (rec)
        ppc_changecrf0(ppc_result_d);
    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODEOVREC (adde, 31, 138,
    ppc_grab_regsdab(instr);
    uint32_t xer_ca       = !!(ppc_state.spr[SPR::XER] & XER::CA);
    uint32_t ppc_result_d = ppc_result_a + ppc_result_b + xer_ca;

    if ((ppc_result_d < ppc_result_a) || (xer_ca && (ppc_result_d == ppc_result_a))) {
        ppc_set_xer(XER::CA);
    } else {
        ppc_unset_xer(XER::CA);
    }

    if (ov)
        ppc_setsoov(ppc_result_a, ~ppc_result_b, ppc_result_d);
    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODEOVREC (addme, 31, 234,
    ppc_grab_regsda(instr);
    uint32_t xer_ca       = !!(ppc_state.spr[SPR::XER] & XER::CA);
    uint32_t ppc_result_d = ppc_result_a + xer_ca - 1;

    if (((xer_ca - 1) < 0xFFFFFFFFUL) || (ppc_result_d < ppc_result_a)) {
        ppc_set_xer(XER::CA);
    } else {
        ppc_unset_xer(XER::CA);
    }

    if (ov)
        ppc_setsoov(ppc_result_a, 0, ppc_result_d);
    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODEOVREC (addze, 31, 202,
    ppc_grab_regsda(instr);
    uint32_t grab_xer     = !!(ppc_state.spr[SPR::XER] & XER::CA);
    uint32_t ppc_result_d = ppc_result_a + grab_xer;

    if (ppc_result_d < ppc_result_a) {
        ppc_set_xer(XER::CA);
    } else {
        ppc_unset_xer(XER::CA);
    }

    if (ov)
        ppc_setsoov(ppc_result_a, 0xFFFFFFFFUL, ppc_result_d);
    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODE (subfic, , 8,
    ppc_grab_regsdasimm(instr);
    uint32_t ppc_result_d = simm - ppc_result_a;
    if (simm == -1) { 
        ppc_set_xer(XER::CA);
    } 
    else { 
        ppc_carry(~ppc_result_a, ppc_result_d);
    }
    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODECARRY (subf, 31, 8,
    ppc_grab_regsdab(instr);
    uint32_t ppc_result_d = ppc_result_b - ppc_result_a;

    if (carry)
        ppc_carry_sub(ppc_result_a, ppc_result_b);
    if (ov)
        ppc_setsoov(ppc_result_b, ppc_result_a, ppc_result_d);
    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODEOVREC (subfe, 31, 136,
    ppc_grab_regsdab(instr);
    uint32_t grab_ca      = !!(ppc_state.spr[SPR::XER] & XER::CA);
    uint32_t ppc_result_d = ~ppc_result_a + ppc_result_b + grab_ca;
    if (grab_ca && ppc_result_b == 0xFFFFFFFFUL)
        ppc_set_xer(XER::CA);
    else
        ppc_carry(~ppc_result_a, ppc_result_d);

    if (ov)
        ppc_setsoov(ppc_result_b, ppc_result_a, ppc_result_d);
    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODEOVREC (subfme, 31, 232,
    ppc_grab_regsda(instr);
    uint32_t grab_ca      = !!(ppc_state.spr[SPR::XER] & XER::CA);
    uint32_t ppc_result_d = ~ppc_result_a + grab_ca - 1;

    if (ppc_result_a == 0xFFFFFFFFUL && !grab_ca) {
        ppc_unset_xer(XER::CA); 
    } 
    else {
        ppc_set_xer(XER::CA);
    }

    if (ov) {
        if (ppc_result_d == ppc_result_a && int32_t(ppc_result_d) > 0) {
            ppc_set_xer(XER::SO | XER::OV);
        } 
        else {
            ppc_unset_xer(XER::OV);
        }
    }

    if (rec) {   
        ppc_changecrf0(ppc_result_d); 
    }
        

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODEOVREC (subfze, 31, 200,
    ppc_grab_regsda(instr);
    uint32_t grab_ca      = !!(ppc_state.spr[SPR::XER] & XER::CA);
    uint32_t ppc_result_d = ~ppc_result_a + grab_ca;

    if (!ppc_result_d && grab_ca) {    // special case: ppc_result_d = 0 and CA=1
        ppc_set_xer(XER::CA);
    } 
    else { 
        ppc_unset_xer(XER::CA); 
    }

    if (ov) {
        if (ppc_result_d && ppc_result_d == ppc_result_a) {
            ppc_set_xer(XER::SO | XER::OV);
        } 
        else {
            ppc_unset_xer(XER::OV);
        }
    }

    if (rec) {   
        ppc_changecrf0(ppc_result_d); 
    }

    ppc_store_iresult_reg(reg_d, ppc_result_d);
 )

OPCODESHIFT (andirc, , 28,
    ppc_grab_regssauimm(instr);
    ppc_result_a = shift ? (ppc_result_d & (uimm << 16)) : (ppc_result_d & uimm);
    ppc_changecrf0(ppc_result_a);
    ppc_store_iresult_reg(reg_a, ppc_result_a);
)

OPCODESHIFT (ori, , 24,
    ppc_grab_regssauimm(instr);
    ppc_result_a = shift ? (ppc_result_d | (uimm << 16)) : (ppc_result_d | uimm);
    ppc_store_iresult_reg(reg_a, ppc_result_a);
)

OPCODESHIFT (xori, , 26,
    ppc_grab_regssauimm(instr);
    ppc_result_a = shift ? (ppc_result_d ^ (uimm << 16)) : (ppc_result_d ^ uimm);
    ppc_store_iresult_reg(reg_a, ppc_result_a);
)

OPCODELOGIC(logical, 31, 28,
    ppc_grab_regssab(instr);
    if (logical_op == logical_fun::ppc_and)
        ppc_result_a = ppc_result_d & ppc_result_b;
    else if (logical_op == logical_fun::ppc_andc)
        ppc_result_a = ppc_result_d & ~(ppc_result_b);
    else if (logical_op == logical_fun::ppc_eqv)
        ppc_result_a = ~(ppc_result_d ^ ppc_result_b);
    else if (logical_op == logical_fun::ppc_nand)
        ppc_result_a = ~(ppc_result_d & ppc_result_b);
    else if (logical_op == logical_fun::ppc_nor)
        ppc_result_a = ~(ppc_result_d | ppc_result_b);
    else if (logical_op == logical_fun::ppc_or)
        ppc_result_a = ppc_result_d | ppc_result_b;
    else if (logical_op == logical_fun::ppc_orc)
        ppc_result_a = ppc_result_d | ~(ppc_result_b);
    else if (logical_op == logical_fun::ppc_xor)
        ppc_result_a = ppc_result_d ^ ppc_result_b;

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_store_iresult_reg(reg_a, ppc_result_a);
)

OPCODEOVREC (neg, 31, 104,
    ppc_grab_regsda(instr);
    uint32_t ppc_result_d = ~(ppc_result_a) + 1;

    if (ov) {
        if (ppc_result_a == 0x80000000)
            ppc_set_xer(XER::SO | XER::OV);
        else
            ppc_unset_xer(XER::OV);
    }

    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)


#ifdef __builtin_clz    // for GCC and Clang users
OPCODEREC (cntlzw, 31, 26,
    ppc_grab_regssa(instr);

    uint32_t bit_check = ppc_result_d;
    uint32_t lead = !bit_check ? 32 : __builtin_clz(bit_check);

    if (rec) 
        ppc_changecrf0(lead);

    ppc_store_iresult_reg(reg_a, lead);
        )
#elif defined __lzcnt    // for Visual C++ users
OPCODEREC (cntlzw, 31, 26,
    ppc_grab_regssa(instr);

    uint32_t bit_check = ppc_result_d;
    uint32_t lead = __lzcnt(bit_check);

    if (rec) 
        ppc_changecrf0(lead);

    ppc_store_iresult_reg(reg_a, lead);
)
#else
OPCODEREC (cntlzw, 31, 26,
    ppc_grab_regssa(instr);

    uint32_t bit_check = ppc_result_d;

    uint32_t lead, mask = 0;

    for (mask = 0x80000000UL, lead = 0; mask != 0; lead++, mask >>= 1) {
        if (bit_check & mask) {
            break;
        }
    }

    if (rec) 
        ppc_changecrf0(lead);

    ppc_store_iresult_reg(reg_a, lead);
)
#endif

OPCODEREC (mulhwu, 31, 11,
    ppc_grab_regsdab(instr);
    uint64_t product = uint64_t(ppc_result_a) * uint64_t(ppc_result_b);
    uint32_t ppc_result_d = uint32_t(product >> 32);

    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODEREC (mulhw, 31, 75,
    ppc_grab_regsdab(instr);
    int64_t product = int64_t(int32_t(ppc_result_a)) * int64_t(int32_t(ppc_result_b));
    uint32_t ppc_result_d = product >> 32;

    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODEOVREC (mullw, 31, 235,
    ppc_grab_regsdab(instr);
    int64_t product = int64_t(int32_t(ppc_result_a)) * int64_t(int32_t(ppc_result_b));

    if (ov) {
        if (product != int64_t(int32_t(product))) {
            ppc_set_xer(XER::SO | XER::OV);
        } else {
            ppc_unset_xer(XER::OV);
        }
    }

    uint32_t ppc_result_d = (uint32_t)product;

    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODE (mulli, , 7,
    ppc_grab_regsdasimm(instr);
    int64_t product          = int64_t(int32_t(ppc_result_a)) * int64_t(int32_t(simm));
    uint32_t ppc_result_d    = uint32_t(product);
    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODEOVREC (divw, 31, 491,
    uint32_t ppc_result_d = 0;
    ppc_grab_regsdab(instr);

    if (!ppc_result_b) { // handle the "anything / 0" case
        ppc_result_d = 0; // tested on G4 in Mac OS X 10.4 and Open Firmware.
        // ppc_result_d = (int32_t(ppc_result_a) < 0) ? -1 : 0; /* UNDOCUMENTED! */

        if (ov) {
            ppc_set_xer(XER::SO | XER::OV);
        }

    } 
    else if (ppc_result_a == 0x80000000UL && ppc_result_b == 0xFFFFFFFFUL) {
        ppc_result_d = 0; // tested on G4 in Mac OS X 10.4 and Open Firmware.

        if (ov)
            ppc_set_xer(XER::SO | XER::OV);

    } 
    else { // normal signed devision
        ppc_result_d = int32_t(ppc_result_a) / int32_t(ppc_result_b);

        if (ov)
            ppc_unset_xer(XER::OV);
    }

    if (rec)
        ppc_changecrf0(ppc_result_d);

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODEOVREC (divwu, 31, 459,
    uint32_t ppc_result_d = 0;
    ppc_grab_regsdab(instr);

    if (!ppc_result_b) { // division by zero

        if (ov) {
            ppc_set_xer(XER::SO | XER::OV);
        }

        if (rec) {
            ppc_state.cr |= XER::CA;
        }
            

    } else {
        ppc_result_d = ppc_result_a / ppc_result_b;

        if (ov) {
            ppc_unset_xer(XER::OV);
        }
    } 
    if (rec) {
        ppc_changecrf0(ppc_result_d);

    }

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

// Value shifting

OPCODESHIFTREC (shift, 31, 24,
    ppc_grab_regssab(instr);
    if (ppc_result_b & 0x20) {
        ppc_result_a = 0;
    }
    else {
        ppc_result_a = (isleft ? (ppc_result_d << (ppc_result_b & 0x1F))
                              : (ppc_result_d >> (ppc_result_b & 0x1F)));
    } 
    if (rec) { 
        ppc_changecrf0(ppc_result_a);
    }
    ppc_store_iresult_reg(reg_a, ppc_result_a);
)

OPCODEREC (sraw, 31, 792,
    ppc_grab_regssab(instr);

    // clear XER[CA] by default
    ppc_unset_xer(XER::CA);

    if (ppc_result_b & 0x20) {
        // fill rA with the sign bit of rS
        ppc_result_a = int32_t(ppc_result_d) >> 31;
        if (ppc_result_a) // if rA is negative
            ppc_set_xer(XER::CA);
    } else {
        uint32_t shift = ppc_result_b & 0x1F;
        ppc_result_a   = int32_t(ppc_result_d) >> shift;
        if ((int32_t(ppc_result_d) < 0) && (ppc_result_d & ((1U << shift) - 1)))
            ppc_set_xer(XER::CA);
    }

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_store_iresult_reg(reg_a, ppc_result_a);
)

OPCODEREC (srawi, 31, 824,
    ppc_grab_regssash(instr);

    // clear XER[CA] by default
    ppc_unset_xer(XER::CA);

    if ((int32_t(ppc_result_d) < 0) && (ppc_result_d & ((1U << rot_sh) - 1))) {
        ppc_set_xer(XER::CA);
    }

    ppc_result_a = int32_t(ppc_result_d) >> rot_sh;

    if (rec) { 
        ppc_changecrf0(ppc_result_a);
    }

    ppc_store_iresult_reg(reg_a, ppc_result_a);
)

OPCODE(rlwimi, , 20,
    ppc_grab_regssash(instr);
    unsigned rot_mb = (instr >> 6) & 0x1F;
    unsigned rot_me = (instr >> 1) & 0x1F;
    uint32_t mask   = rot_mask(rot_mb, rot_me);
    uint32_t r      = rot_sh ? ((ppc_result_d << rot_sh) |
                      (ppc_result_d >> (32 - rot_sh))) : ppc_result_d;
    ppc_result_a    = (ppc_result_a & ~mask) | (r & mask);
    if ((instr & 0x01) == 1) {
        ppc_changecrf0(ppc_result_a);
    }
    ppc_store_iresult_reg(reg_a, ppc_result_a);
)

OPCODE (rlwinm, , 21,
    ppc_grab_regssash(instr);
    unsigned rot_mb = (instr >> 6) & 0x1F;
    unsigned rot_me = (instr >> 1) & 0x1F;
    uint32_t mask   = rot_mask(rot_mb, rot_me);
    uint32_t r      = rot_sh ? ((ppc_result_d << rot_sh) |
                      (ppc_result_d >> (32 - rot_sh))) : ppc_result_d;
    ppc_result_a    = r & mask;
    if ((instr & 0x01) == 1) {
        ppc_changecrf0(ppc_result_a);
    }
    ppc_store_iresult_reg(reg_a, ppc_result_a);
)

OPCODE (rlwnm, , 23,
    ppc_grab_regssab(instr);
    ppc_result_b &= 0x1F;
    unsigned rot_mb = (instr >> 6) & 0x1F;
    unsigned rot_me = (instr >> 1) & 0x1F;
    uint32_t mask   = rot_mask(rot_mb, rot_me);
    uint32_t rot    = ppc_result_b & 0x1F;
    uint32_t r      = rot ? ((ppc_result_d << rot) |
                      (ppc_result_d >> (32 - rot))) : ppc_result_d;
    ppc_result_a    = r & mask;
    if ((instr & 0x01) == 1) {
        ppc_changecrf0(ppc_result_a);
    }
    ppc_store_iresult_reg(reg_a, ppc_result_a);
)

OPCODE31(mfcr, 31, 19,
    int reg_d            = (instr >> 21) & 0x1F;
    ppc_state.gpr[reg_d] = ppc_state.cr;
)

OPCODE31 (mtsr, 31, 210,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif
    if (ppc_state.msr & MSR::PR) {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::NOT_ALLOWED);
    }
    int reg_s             = (instr >> 21) & 0x1F;
    uint32_t grab_sr      = (instr >> 16) & 0x0F;
   if (ppc_state.sr[grab_sr] != ppc_state.gpr[reg_s]) {
        ppc_state.sr[grab_sr] = ppc_state.gpr[reg_s];
        mmu_pat_ctx_changed();
   }
)

OPCODE31 (mtsrin, 31, 242,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif
    if (ppc_state.msr & MSR::PR) {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::NOT_ALLOWED);
    }
    ppc_grab_regssb(instr);
    uint32_t grab_sr      = ppc_result_b >> 28;
    if (ppc_state.sr[grab_sr] != ppc_result_d) {
        ppc_state.sr[grab_sr] = ppc_result_d;
        mmu_pat_ctx_changed();
    }
)

OPCODE31 (mfsr, 31, 595,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif
    if (ppc_state.msr & MSR::PR) {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::NOT_ALLOWED);
    }
    int reg_d            = (instr >> 21) & 0x1F;
    uint32_t grab_sr     = (instr >> 16) & 0x0F;
    ppc_state.gpr[reg_d] = ppc_state.sr[grab_sr];
)

OPCODE31 (mfsrin, 31, 659,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif
    if (ppc_state.msr & MSR::PR) {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::NOT_ALLOWED);
    }
    ppc_grab_regsdb(instr);
    uint32_t grab_sr     = ppc_result_b >> 28;
    ppc_state.gpr[reg_d] = ppc_state.sr[grab_sr];
)

OPCODE (mfmsr, 31, 83,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif
    if (ppc_state.msr & MSR::PR) {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::NOT_ALLOWED);
    }
    uint32_t reg_d       = (instr >> 21) & 0x1F;
    ppc_state.gpr[reg_d] = ppc_state.msr;
)

OPCODE (mtmsr, 31, 146,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif
    if (ppc_state.msr & MSR::PR) {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::NOT_ALLOWED);
    }
    uint32_t reg_s = (instr >> 21) & 0x1F;
    ppc_state.msr = ppc_state.gpr[reg_s];

    // generate External Interrupt Exception
    // if CPU interrupt line is asserted
    if (ppc_state.msr & MSR::EE && int_pin) {
        //LOG_F(WARNING, "MTMSR: CPU INT pending, generate CPU exception");
        ppc_exception_handler(Except_Type::EXC_EXT_INT, 0);
    } else if ((ppc_state.msr & MSR::EE) && dec_exception_pending) {
        dec_exception_pending = false;
        //LOG_F(WARNING, "MTMSR: decrementer exception triggered");
        ppc_exception_handler(Except_Type::EXC_DECR, 0);
    } else {
        mmu_change_mode();
    }
)

OPCODE31 (mfspr, 31, 339,
    ppc_grab_dab(instr);
    uint32_t ref_spr = (reg_b << 5) | reg_a;

    if (ref_spr & 0x10) {
#ifdef CPU_PROFILING
        num_supervisor_instrs++;
#endif
        if (ppc_state.msr & MSR::PR) {
            ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::NOT_ALLOWED);
        }
    }

    switch (ref_spr) {
    case SPR::MQ:
        if (!is_601) {
            ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
        }
        ppc_state.gpr[reg_d] = ppc_state.spr[ref_spr];
        break;
    case SPR::RTCL_U:
        if (!is_601) {
            ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
        }
        calc_rtcl_value();
        ppc_state.gpr[reg_d] =
        ppc_state.spr[SPR::RTCL_S] = rtc_lo & 0x3FFFFF80UL;
        ppc_state.spr[SPR::RTCU_S] = rtc_hi;
        break;
    case SPR::RTCU_U:
        if (!is_601) {
            ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
        }
        calc_rtcl_value();
        ppc_state.gpr[reg_d] =
        ppc_state.spr[SPR::RTCU_S] = rtc_hi;
        ppc_state.spr[SPR::RTCL_S] = rtc_lo;
        break;
    case SPR::DEC_U:
        if (!is_601) {
            ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
        }
        // fallthrough
    case SPR::DEC_S:
        ppc_state.gpr[reg_d] = ppc_state.spr[SPR::DEC_S] = calc_dec_value();
        break;
    default:
        // FIXME: Unknown SPR should be noop or illegal instruction.
        ppc_state.gpr[reg_d] = ppc_state.spr[ref_spr];
    }
)

OPCODE31 (mtspr, 31, 467,
    ppc_grab_dab(instr);
    uint32_t ref_spr = (reg_b << 5) | reg_a;

    if (ref_spr & 0x10) {
#ifdef CPU_PROFILING
        num_supervisor_instrs++;
#endif
        if (ppc_state.msr & MSR::PR) {
            ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::NOT_ALLOWED);
        }
    }

    uint32_t val = ppc_state.gpr[reg_d];

    switch (ref_spr) {
    case SPR::MQ:
        if (!is_601) {
            ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
        }
        ppc_state.spr[ref_spr] = val;
        break;
    case SPR::RTCL_U:
    case SPR::RTCU_U:
    case SPR::DEC_U:
        if (!is_601) {
            ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
        }
        break;
    case SPR::XER:
        ppc_state.spr[ref_spr] = val & 0xe000ff7f;
        break;
    case SPR::SDR1:
        if (ppc_state.spr[ref_spr] != val) {
            ppc_state.spr[ref_spr] = val;
            mmu_pat_ctx_changed(); // adapt to SDR1 changes
        }
        break;
    case SPR::RTCL_S:
        calc_rtcl_value();
        ppc_state.spr[RTCL_S] = rtc_lo = val & 0x3FFFFF80UL;
        ppc_state.spr[RTCU_S] = rtc_hi;
        break;
    case SPR::RTCU_S:
        calc_rtcl_value();
        ppc_state.spr[RTCL_S] = rtc_lo;
        ppc_state.spr[RTCU_S] = rtc_hi = val;
        break;
    case SPR::DEC_S:
        ppc_state.spr[DEC_S] = val;
        update_decrementer(val);
        break;
    case SPR::TBL_S:
        update_timebase(0xFFFFFFFF00000000ULL, val);
        ppc_state.spr[TBL_S] = val;
        ppc_state.spr[TBU_S] = tbr_wr_value >> 32;
        break;
    case SPR::TBU_S:
        update_timebase(0x00000000FFFFFFFFULL, uint64_t(val) << 32);
        ppc_state.spr[TBL_S] = (uint32_t)tbr_wr_value;
        ppc_state.spr[TBU_S] = val;
        break;
    case SPR::PVR:
        break;
    case 528:
    case 529:
    case 530:
    case 531:
    case 532:
    case 533:
    case 534:
    case 535:
        ppc_state.spr[ref_spr] = val;
        ibat_update(ref_spr);
        break;
    case 536:
    case 537:
    case 538:
    case 539:
    case 540:
    case 541:
    case 542:
    case 543:
        ppc_state.spr[ref_spr] = val;
        dbat_update(ref_spr);
    default:
        // FIXME: Unknown SPR should be noop or illegal instruction.
        ppc_state.spr[ref_spr] = val;
    }
)

OPCODE31 (mftb, 31, 371,
    ppc_grab_dab(instr);
    uint32_t ref_spr = (reg_b << 5) | reg_a;

    uint64_t tbr_value = calc_tbr_value();

    switch (ref_spr) {
    case SPR::TBL_U:
        ppc_state.gpr[reg_d] =
        ppc_state.spr[TBL_S] = uint32_t(tbr_value);
        ppc_state.spr[TBU_S] = uint32_t(tbr_value >> 32);
        break;
    case SPR::TBU_U:
        ppc_state.gpr[reg_d] =
        ppc_state.spr[TBU_S] = uint32_t(tbr_value >> 32);
        ppc_state.spr[TBL_S] = uint32_t(tbr_value);
        break;
    default:
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
     }
)

OPCODE31 (mtcrf, 31, 144,
    ppc_grab_s(instr);
    uint8_t crm = (instr >> 12) & 0xFFU;

    uint32_t cr_mask = 0;

    if (crm == 0xFFU) // the fast case
        cr_mask = 0xFFFFFFFFUL;
    else { // the slow case
        if (crm & 0x80) cr_mask |= 0xF0000000UL;
        if (crm & 0x40) cr_mask |= 0x0F000000UL;
        if (crm & 0x20) cr_mask |= 0x00F00000UL;
        if (crm & 0x10) cr_mask |= 0x000F0000UL;
        if (crm & 0x08) cr_mask |= 0x0000F000UL;
        if (crm & 0x04) cr_mask |= 0x00000F00UL;
        if (crm & 0x02) cr_mask |= 0x000000F0UL;
        if (crm & 0x01) cr_mask |= 0x0000000FUL;
    }
    ppc_state.cr = (ppc_state.cr & ~cr_mask) | (ppc_result_d & cr_mask);
)

OPCODE31 (mcrxr, 31, 512,
    int crf_d    = (instr >> 21) & 0x1C;
    ppc_state.cr = (ppc_state.cr & ~(0xF0000000UL >> crf_d)) |
        ((ppc_state.spr[SPR::XER] & 0xF0000000UL) >> crf_d);
    ppc_state.spr[SPR::XER] &= 0x0FFFFFFF;
)

OPCODEEXTSIGN (exts, 31, 922,
    ppc_grab_regssa(instr);
    ppc_result_a = int32_t(T(ppc_result_d));

    if (rec)
        ppc_changecrf0(ppc_result_a);

    ppc_store_iresult_reg(reg_a, ppc_result_a);
)

// Branching Instructions

OPCODELKAA (b, 18, 0,
    int32_t adr_li = int32_t((instr & ~3UL) << 6) >> 6;

    if (a)
        ppc_next_instruction_address = adr_li;
    else
        ppc_next_instruction_address = uint32_t(ppc_state.pc + adr_li);

    if (l)
        ppc_state.spr[SPR::LR] = uint32_t(ppc_state.pc + 4);

    exec_flags = EXEF_BRANCH;
)

OPCODELKAA (bc, 16, 0,
    uint32_t ctr_ok = 0;
    uint32_t cnd_ok = 0;
    uint32_t br_bo = (instr >> 21) & 0x1F;
    uint32_t br_bi = (instr >> 16) & 0x1F;
    int32_t br_bd  = int32_t(int16_t(instr & ~3UL));

    if (!(br_bo & 0x04)) {
        (ppc_state.spr[SPR::CTR])--; /* decrement CTR */
    }
    ctr_ok = (br_bo & 0x04) | ((ppc_state.spr[SPR::CTR] != 0) == !(br_bo & 0x02));
    cnd_ok = (br_bo & 0x10) | (!(ppc_state.cr & (0x80000000UL >> br_bi)) == !(br_bo & 0x08));

    if (ctr_ok && cnd_ok) {
        if (a) {
            ppc_next_instruction_address = br_bd;
        } 
        else {
            ppc_next_instruction_address = uint32_t(ppc_state.pc + br_bd);
        }
        exec_flags = EXEF_BRANCH;
    }

    if (l)
        ppc_state.spr[SPR::LR] = ppc_state.pc + 4;
)

OPCODE601L (bcctr, 19, 1056,
    uint32_t ctr_ok = 0;
    uint32_t cnd_ok = 0;
    uint32_t br_bo = (instr >> 21) & 0x1F;
    uint32_t br_bi = (instr >> 16) & 0x1F;

    uint32_t ctr = ppc_state.spr[SPR::CTR];
    uint32_t new_ctr;
    if (for601) {
        new_ctr = ctr - 1;
        if (!(br_bo & 0x04)) {
            ppc_state.spr[SPR::CTR] = new_ctr; /* decrement CTR */
        }
    }
    else {
        new_ctr = ctr;
    }
    ctr_ok = (br_bo & 0x04) | ((new_ctr != 0) == !(br_bo & 0x02));
    cnd_ok = (br_bo & 0x10) | (!(ppc_state.cr & (0x80000000UL >> br_bi)) == !(br_bo & 0x08));

    if (ctr_ok && cnd_ok) {
        ppc_next_instruction_address = (ctr & ~3UL);
        exec_flags = EXEF_BRANCH;
    }

    if (l)
        ppc_state.spr[SPR::LR] = ppc_state.pc + 4;
)

OPCODEL (bclr, 19, 32,
    uint32_t br_bo = (instr >> 21) & 0x1F;
    uint32_t br_bi = (instr >> 16) & 0x1F;
    uint32_t ctr_ok = 0;
    uint32_t cnd_ok = 0;

    if (!(br_bo & 0x04)) {
        (ppc_state.spr[SPR::CTR])--; /* decrement CTR */
    }
    ctr_ok = (br_bo & 0x04) | ((ppc_state.spr[SPR::CTR] != 0) == !(br_bo & 0x02));
    cnd_ok = (br_bo & 0x10) | (!(ppc_state.cr & (0x80000000UL >> br_bi)) == !(br_bo & 0x08));

    if (ctr_ok && cnd_ok) {
        ppc_next_instruction_address = (ppc_state.spr[SPR::LR] & ~3UL);
        exec_flags = EXEF_BRANCH;
    }

    if (l)
        ppc_state.spr[SPR::LR] = ppc_state.pc + 4;
)

// Compare Instructions

OPCODE31 (cmp, 31, 0,
#ifdef CHECK_INVALID
    if (instr & 0x200000) {
        LOG_F(WARNING, "Invalid CMP instruction form (L=1)!");
        return;
    }
#endif

    int crf_d = (instr >> 21) & 0x1C;
    ppc_grab_regsab(instr);
    uint32_t xercon = (ppc_state.spr[SPR::XER] & XER::SO) >> 3;
    uint32_t cmp_c = (int32_t(ppc_result_a) == int32_t(ppc_result_b)) ? 0x20000000UL : \
        (int32_t(ppc_result_a) > int32_t(ppc_result_b)) ? 0x40000000UL : 0x80000000UL;
    ppc_state.cr = ((ppc_state.cr & ~(0xf0000000UL >> crf_d)) | ((cmp_c + xercon) >> crf_d));
)

OPCODE (cmpi, , 11,
#ifdef CHECK_INVALID
    if (instr & 0x200000) {
        LOG_F(WARNING, "Invalid CMPI instruction form (L=1)!");
        return;
    }
#endif

    int crf_d = (instr >> 21) & 0x1C;
    ppc_grab_regsasimm(instr);
    uint32_t xercon = (ppc_state.spr[SPR::XER] & XER::SO) >> 3;
    uint32_t cmp_c = (int32_t(ppc_result_a) == simm) ? 0x20000000UL : \
        (int32_t(ppc_result_a) > simm) ? 0x40000000UL : 0x80000000UL;
    ppc_state.cr = ((ppc_state.cr & ~(0xf0000000UL >> crf_d)) | ((cmp_c + xercon) >> crf_d));
)

OPCODE31 (cmpl, 31, 32,
#ifdef CHECK_INVALID
    if (instr & 0x200000) {
        LOG_F(WARNING, "Invalid CMPL instruction form (L=1)!");
        return;
    }
#endif

    int crf_d = (instr >> 21) & 0x1C;
    ppc_grab_regsab(instr);
    uint32_t xercon = (ppc_state.spr[SPR::XER] & XER::SO) >> 3;
    uint32_t cmp_c = (ppc_result_a == ppc_result_b) ? 0x20000000UL : \
        (ppc_result_a > ppc_result_b) ? 0x40000000UL : 0x80000000UL;
    ppc_state.cr = ((ppc_state.cr & ~(0xf0000000UL >> crf_d)) | ((cmp_c + xercon) >> crf_d));
)

OPCODE (cmpli, , 10,
#ifdef CHECK_INVALID
    if (instr & 0x200000) {
        LOG_F(WARNING, "Invalid CMPLI instruction form (L=1)!");
        return;
    }
#endif
    ppc_grab_crfd_regsauimm(instr);
    uint32_t xercon = (ppc_state.spr[SPR::XER] & XER::SO) >> 3;
    uint32_t cmp_c = (ppc_result_a == uimm) ? 0x20000000UL : \
        (ppc_result_a > uimm) ? 0x40000000UL : 0x80000000UL;
    ppc_state.cr = ((ppc_state.cr & ~(0xf0000000UL >> crf_d)) | ((cmp_c + xercon) >> crf_d));
)

// Condition Register Changes

OPCODE (mcrf, 19, 0,
    int crf_d       = (instr >> 21) & 0x1C;
    int crf_s       = (instr >> 16) & 0x1C;

    // extract and right justify source flags field
    uint32_t grab_s = (ppc_state.cr >> (28 - crf_s)) & 0xF;

    ppc_state.cr = (ppc_state.cr & ~(0xf0000000UL >> crf_d)) | (grab_s << (28 - crf_d));
)

OPCODE (crand, 19, 514,
    ppc_grab_dab(instr);
    uint8_t ir = (ppc_state.cr >> (31 - reg_a)) & (ppc_state.cr >> (31 - reg_b));
    if (ir & 1) {
        ppc_set_cr(0x80000000UL >> reg_d);
    } else {
        ppc_unset_cr(0x80000000UL >> reg_d);
    }
)

OPCODE (crandc, 19, 258,
    ppc_grab_dab(instr);
    if ((ppc_state.cr & (0x80000000UL >> reg_a)) && !(ppc_state.cr & (0x80000000UL >> reg_b))) {
        ppc_set_cr(0x80000000UL >> reg_d);
    } else {
        ppc_unset_cr(0x80000000UL >> reg_d);
    }
)

OPCODE (creqv, 19, 578,
    ppc_grab_dab(instr);
    uint8_t ir = (ppc_state.cr >> (31 - reg_a)) ^ (ppc_state.cr >> (31 - reg_b));
    if (ir & 1) { // compliment is implemented by swapping the following if/else bodies
        ppc_unset_cr(0x80000000UL >> reg_d);
    } else {
        ppc_set_cr(0x80000000UL >> reg_d);
    }
)

OPCODE (crnand, 19, 450,
    ppc_grab_dab(instr);
    uint8_t ir = (ppc_state.cr >> (31 - reg_a)) & (ppc_state.cr >> (31 - reg_b));
    if (ir & 1) {
        ppc_unset_cr(0x80000000UL >> reg_d);
    } else {
        ppc_set_cr(0x80000000UL >> reg_d);
    }
)

OPCODE (crnor, 19, 66,
    ppc_grab_dab(instr);
    uint8_t ir = (ppc_state.cr >> (31 - reg_a)) | (ppc_state.cr >> (31 - reg_b));
    if (ir & 1) {
        ppc_unset_cr(0x80000000UL >> reg_d);
    } else {
        ppc_set_cr(0x80000000UL >> reg_d);
    }
)

OPCODE (cror, 19, 898,
    ppc_grab_dab(instr);
    uint8_t ir = (ppc_state.cr >> (31 - reg_a)) | (ppc_state.cr >> (31 - reg_b));
    if (ir & 1) {
        ppc_set_cr(0x80000000UL >> reg_d);
    } else {
        ppc_unset_cr(0x80000000UL >> reg_d);
    }
)

OPCODE (crorc, 19, 834,
    ppc_grab_dab(instr);
    if ((ppc_state.cr & (0x80000000UL >> reg_a)) || !(ppc_state.cr & (0x80000000UL >> reg_b))) {
        ppc_set_cr(0x80000000UL >> reg_d);
    } else {
        ppc_unset_cr(0x80000000UL >> reg_d);
    }
)

OPCODE (crxor, 19, 386,
    ppc_grab_dab(instr);
    uint8_t ir = (ppc_state.cr >> (31 - reg_a)) ^ (ppc_state.cr >> (31 - reg_b));
    if (ir & 1) {
        ppc_set_cr(0x80000000UL >> reg_d);
    } else {
        ppc_unset_cr(0x80000000UL >> reg_d);
    }
)

// Processor MGMT Fns.

OPCODE (rfi, 19, 100,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif
    uint32_t new_srr1_val   = (ppc_state.spr[SPR::SRR1] & 0x87C0FF73UL);
    uint32_t new_msr_val    = (ppc_state.msr & ~0x87C0FF73UL);
    ppc_state.msr           = (new_msr_val | new_srr1_val) & 0xFFFBFFFFUL;

    // generate External Interrupt Exception
    // if CPU interrupt line is still asserted
    if (ppc_state.msr & MSR::EE && int_pin) {
        uint32_t save_srr0 = ppc_state.spr[SPR::SRR0] & ~3UL;
        ppc_exception_handler(Except_Type::EXC_EXT_INT, 0);
        ppc_state.spr[SPR::SRR0] = save_srr0;
        return;
    }

    if ((ppc_state.msr & MSR::EE) && dec_exception_pending) {
        dec_exception_pending = false;
        //LOG_F(WARNING, "decrementer exception from rfi msr:0x%X", ppc_state.msr);
        uint32_t save_srr0 = ppc_state.spr[SPR::SRR0] & ~3UL;
        ppc_exception_handler(Except_Type::EXC_DECR, 0);
        ppc_state.spr[SPR::SRR0] = save_srr0;
        return;
    }

    ppc_next_instruction_address = ppc_state.spr[SPR::SRR0] & ~3UL;

    do_ctx_sync(); // RFI is context synchronizing

    mmu_change_mode();

    exec_flags = EXEF_RFI;
)

OPCODE (sc, , 17,
    do_ctx_sync(); // SC is context synchronizing!
    ppc_exception_handler(Except_Type::EXC_SYSCALL, 0x20000);
)

OPCODE31 (tw, 31, 4,
    uint32_t reg_a  = (instr >> 11) & 0x1F;
    uint32_t reg_b  = (instr >> 16) & 0x1F;
    uint32_t ppc_to = (instr >> 21) & 0x1F;
    if (((int32_t(ppc_state.gpr[reg_a]) < int32_t(ppc_state.gpr[reg_b])) && (ppc_to & 0x10)) ||
        ((int32_t(ppc_state.gpr[reg_a]) > int32_t(ppc_state.gpr[reg_b])) && (ppc_to & 0x08)) ||
        ((int32_t(ppc_state.gpr[reg_a]) == int32_t(ppc_state.gpr[reg_b])) && (ppc_to & 0x04)) ||
        ((ppc_state.gpr[reg_a] < ppc_state.gpr[reg_b]) && (ppc_to & 0x02)) ||
        ((ppc_state.gpr[reg_a] > ppc_state.gpr[reg_b]) && (ppc_to & 0x01))) {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::TRAP);
    }
)

OPCODE (twi, , 3,
    int32_t simm    = int32_t(int16_t(instr));
    uint32_t reg_a  = (instr >> 16) & 0x1F;
    uint32_t ppc_to = (instr >> 21) & 0x1F;
    if (((int32_t(ppc_state.gpr[reg_a]) < simm) && (ppc_to & 0x10)) ||
        ((int32_t(ppc_state.gpr[reg_a]) > simm) && (ppc_to & 0x08)) ||
        ((int32_t(ppc_state.gpr[reg_a]) == simm) && (ppc_to & 0x04)) ||
        (ppc_state.gpr[reg_a] < uint32_t(simm) && (ppc_to & 0x02)) ||
        (ppc_state.gpr[reg_a] > uint32_t(simm) && (ppc_to & 0x01))) {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::TRAP);
    }
)

OPCODE31 (eieio, 31, 854,
    /* placeholder */
)

OPCODE (isync, 19, 300,
    do_ctx_sync();
)

OPCODE31 (sync, 31, 598,
    /* placeholder */
)

OPCODE31 (icbi, 31, 982,
    /* placeholder */
)

OPCODE31 (dcbf, 31, 86,
    /* placeholder */
)

OPCODE31 (dcbi, 31, 470,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif
    /* placeholder */
)

OPCODE31 (dcbst, 31, 54,
    /* placeholder */
)

OPCODE31 (dcbt, 31, 278,
    // Not needed, the HDI reg is touched to no-op this instruction.
    return;
)

OPCODE31 (dcbtst, 31, 246,
    // Not needed, the HDI reg is touched to no-op this instruction.
    return;
)

OPCODE31 (dcbz, 31, 1014,
    ppc_grab_regsab(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);

    ea &= 0xFFFFFFE0UL; // align EA on a 32-byte boundary

    // the following is not especially efficient but necessary
    // to make BlockZero under Mac OS 8.x and later to work
    mmu_write_vmem<uint64_t>(ea + 0, instr, 0);
    mmu_write_vmem<uint64_t>(ea + 8, instr, 0);
    mmu_write_vmem<uint64_t>(ea + 16, instr, 0);
    mmu_write_vmem<uint64_t>(ea + 24, instr, 0);
)


// Integer Load and Store Functions

OPCODEMEM (st, , 36,
#ifdef CPU_PROFILING
    num_int_stores++;
#endif
    ppc_grab_regssa(instr);
    uint32_t ea = int32_t(int16_t(instr));
    ea += reg_a ? ppc_result_a : 0;
    mmu_write_vmem<T>(ea, instr, ppc_result_d);
)

OPCODEMEMINDEXED (stx, 31, 151,
#ifdef CPU_PROFILING
    num_int_stores++;
#endif
    ppc_grab_regssab(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);
    mmu_write_vmem<T>(ea, instr, ppc_result_d);
)

OPCODEMEM (stu, , 37,
#ifdef CPU_PROFILING
    num_int_stores++;
#endif
    ppc_grab_regssa(instr);
    if (reg_a != 0) {
        uint32_t ea = int32_t(int16_t(instr));
        ea += ppc_result_a;
        mmu_write_vmem<T>(ea, instr, ppc_result_d);
        ppc_state.gpr[reg_a] = ea;
    } else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODEMEMINDEXED (stux, 31, 183,
#ifdef CPU_PROFILING
    num_int_stores++;
#endif
    ppc_grab_regssab(instr);
    if (reg_a != 0) {
        uint32_t ea = ppc_result_a + ppc_result_b;
        mmu_write_vmem<T>(ea, instr, ppc_result_d);
        ppc_state.gpr[reg_a] = ea;
    } 
    else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODE (sthbrx, 31, 918,
#ifdef CPU_PROFILING
    num_int_stores++;
#endif
    ppc_grab_regssab(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);
    ppc_result_d = uint32_t(BYTESWAP_16(uint16_t(ppc_result_d)));
    mmu_write_vmem<uint16_t>(ea, instr, ppc_result_d);
)

OPCODE (stwcx, 31, 301,
#ifdef CPU_PROFILING
    num_int_stores++;
#endif
    ppc_grab_regssab(instr);
    uint32_t ea = (reg_a == 0) ? ppc_result_b : (ppc_result_a + ppc_result_b);
    ppc_state.cr &= 0x0FFFFFFFUL; // clear CR0
    ppc_state.cr |= (ppc_state.spr[SPR::XER] & XER::SO) >> 3; // copy XER[SO] to CR0[SO]
    if (ppc_state.reserve) {
        mmu_write_vmem<uint32_t>(ea, instr, ppc_result_d);
        ppc_state.reserve = false;
        ppc_state.cr |= 0x20000000UL; // set CR0[EQ]
    }
)

OPCODE (stwbrx, 31, 662,
#ifdef CPU_PROFILING
    num_int_stores++;
#endif
    ppc_grab_regssab(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);
    ppc_result_d          = BYTESWAP_32(ppc_result_d);
    mmu_write_vmem<uint32_t>(ea, instr, ppc_result_d);
)

OPCODE (stmw, , 47,
    ppc_grab_regssa_stmw(instr);
    uint32_t ea = int32_t(int16_t(instr));
    ea += reg_a ? ppc_result_a : 0;

    /* what should we do if EA is unaligned? */
    if (ea & 3) {
        ppc_alignment_exception(ea, instr);
    }

    for (; reg_s <= 31; reg_s++) {
        mmu_write_vmem<uint32_t>(ea, instr, ppc_state.gpr[reg_s]);
        ea += 4;
    }
)

OPCODEMEM (lz, , 32,
    #ifdef CPU_PROFILING
        num_int_loads++;
    #endif
    ppc_grab_regsda(instr);
    uint32_t ea = int32_t(int16_t(instr));
    ea += reg_a ? ppc_result_a : 0;
    uint32_t ppc_result_d = mmu_read_vmem<T>(ea, instr);
    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODEMEM (lzu, , 33,
    ppc_grab_regsda(instr);
    uint32_t ea = int32_t(int16_t(instr));
    if ((reg_a != reg_d) && reg_a != 0) {
        ea += ppc_result_a;
        uint32_t ppc_result_d = mmu_read_vmem<T>(ea, instr);
        uint32_t ppc_result_a = ea;
        ppc_store_iresult_reg(reg_d, ppc_result_d);
        ppc_store_iresult_reg(reg_a, ppc_result_a);
    } else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODEMEMINDEXED (lzx, 31, 23,
    ppc_grab_regsdab(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);
    uint32_t ppc_result_d = mmu_read_vmem<T>(ea, instr);
    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODEMEMINDEXED (lzux, 31, 55,
    ppc_grab_regsdab(instr);
    if ((reg_a != reg_d) && reg_a != 0) {
        uint32_t ea = ppc_result_a + ppc_result_b;
        uint32_t ppc_result_d = mmu_read_vmem<T>(ea, instr);
        ppc_result_a          = ea;
        ppc_store_iresult_reg(reg_d, ppc_result_d);
        ppc_store_iresult_reg(reg_a, ppc_result_a);
    } else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODE (lha, , 42,
#ifdef CPU_PROFILING
    num_int_loads++;
#endif
    ppc_grab_regsda(instr);
    uint32_t ea = int32_t(int16_t(instr));
    ea += (reg_a ? ppc_result_a : 0);
    int16_t val = mmu_read_vmem<uint16_t>(ea, instr);
    ppc_state.gpr[reg_d] = int32_t(val);
)

OPCODE (lhau, , 43,
#ifdef CPU_PROFILING
    num_int_loads++;
#endif
    ppc_grab_regsda(instr);
    if ((reg_a != reg_d) && reg_a != 0) {
        uint32_t ea = int32_t(int16_t(instr));
        ea += ppc_result_a;
        int16_t val = mmu_read_vmem<uint16_t>(ea, instr);
        ppc_state.gpr[reg_d] = int32_t(val);
        uint32_t ppc_result_a = ea;
        ppc_store_iresult_reg(reg_a, ppc_result_a);
    } else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODE31 (lhaux, 31, 375,
#ifdef CPU_PROFILING
    num_int_loads++;
#endif
    ppc_grab_regsdab(instr);
    if ((reg_a != reg_d) && reg_a != 0) {
        uint32_t ea = ppc_result_a + ppc_result_b;
        int16_t val = mmu_read_vmem<uint16_t>(ea, instr);
        ppc_state.gpr[reg_d] = int32_t(val);
        uint32_t ppc_result_a = ea;
        ppc_store_iresult_reg(reg_a, ppc_result_a);
    }
    else {
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
)

OPCODE31 (lhax, 31, 343,
#ifdef CPU_PROFILING
    num_int_loads++;
#endif
    ppc_grab_regsdab(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);
    int16_t val = mmu_read_vmem<uint16_t>(ea, instr);
    ppc_state.gpr[reg_d] = int32_t(val);
)

OPCODE31 (lhbrx, 31, 790,
#ifdef CPU_PROFILING
    num_int_loads++;
#endif
    ppc_grab_regsdab(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);
    uint32_t ppc_result_d = uint32_t(BYTESWAP_16(mmu_read_vmem<uint16_t>(ea, instr)));
    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODE31 (lwbrx, 31, 534,
#ifdef CPU_PROFILING
    num_int_loads++;
#endif
    ppc_grab_regsdab(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);
    uint32_t ppc_result_d = BYTESWAP_32(mmu_read_vmem<uint32_t>(ea, instr));
    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODE31 (lwarx, 31, 20,
#ifdef CPU_PROFILING
    num_int_loads++;
#endif
    // Placeholder - Get the reservation of memory implemented!
    ppc_grab_regsdab(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);
    ppc_state.reserve     = true;
    uint32_t ppc_result_d = mmu_read_vmem<uint32_t>(ea, instr);
    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODE (lmw, , 46,
    ppc_grab_regsda(instr);
    uint32_t ea = int32_t(int16_t(instr));
    ea += (reg_a ? ppc_result_a : 0);
    // How many words to load in memory - using a do-while for this
    do {
        ppc_state.gpr[reg_d] = mmu_read_vmem<uint32_t>(ea, instr);
       ea += 4;
       reg_d++;
    } while (reg_d < 32);
)

OPCODE31 (lswi, 31, 597,
#ifdef CPU_PROFILING
    num_int_loads++;
#endif
    ppc_grab_regsda(instr);
    uint32_t ea = reg_a ? ppc_result_a : 0;
    uint32_t grab_inb = (instr >> 11) & 0x1F;
    grab_inb          = grab_inb ? grab_inb : 32;

    while (grab_inb >= 4) {
        ppc_state.gpr[reg_d] = mmu_read_vmem<uint32_t>(ea, instr);
        reg_d++;
        if (reg_d >= 32) {    // wrap around through GPR0
            reg_d = 0;
        }
        ea += 4;
        grab_inb -= 4;
    }

    // handle remaining bytes
    switch (grab_inb) {
    case 1:
        ppc_state.gpr[reg_d] = mmu_read_vmem<uint8_t>(ea, instr) << 24;
        break;
    case 2:
        ppc_state.gpr[reg_d] = mmu_read_vmem<uint16_t>(ea, instr) << 16;
        break;
    case 3:
        ppc_state.gpr[reg_d] = mmu_read_vmem<uint16_t>(ea, instr) << 16;
        ppc_state.gpr[reg_d] += mmu_read_vmem<uint8_t>(ea + 2, instr) << 8;
        break;
    default:
        break;
    }
)

OPCODE31 (lswx, 31, 533,
#ifdef CPU_PROFILING
    num_int_loads++;
#endif
    ppc_grab_regsdab(instr);

/*
    // Invalid instruction forms
    if ((reg_d == 0 && reg_a == 0) || (reg_d == reg_a) || (reg_d == reg_b)) {
        // UNTESTED! Does invalid form really cause exception?
        // G4 doesn't do exception
        ppc_exception_handler(Except_Type::EXC_PROGRAM, Exc_Cause::ILLEGAL_OP);
    }
*/

    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);
    uint32_t grab_inb      = ppc_state.spr[SPR::XER] & 0x7F;

    for (;;) {
        if (is_601 && (reg_d == reg_b || (reg_a != 0 && reg_d == reg_a))) {
            // UNTESTED! MPC601 manual is inconsistant on whether reg_b is skipped or not
            reg_d = (reg_d + 1) & 0x1F; // wrap around through GPR0
        }
        switch (grab_inb) {
        case 0:
            return;
        case 1:
            ppc_state.gpr[reg_d] = mmu_read_vmem<uint8_t>(ea, instr) << 24;
            return;
        case 2:
            ppc_state.gpr[reg_d] = mmu_read_vmem<uint16_t>(ea, instr) << 16;
            return;
        case 3:
            ppc_state.gpr[reg_d] = (mmu_read_vmem<uint16_t>(ea, instr) << 16) |
                (mmu_read_vmem<uint8_t>(ea + 2, instr) << 8);
            return;
        }
        ppc_state.gpr[reg_d] = mmu_read_vmem<uint32_t>(ea, instr);
        reg_d = (reg_d + 1) & 0x1F; // wrap around through GPR0
        ea += 4;
        grab_inb -= 4;
    }
)

OPCODE31 (stswi, 31, 725,
#ifdef CPU_PROFILING
    num_int_stores++;
#endif
    ppc_grab_regssash_stswi(instr);
    uint32_t ea = reg_a ? ppc_result_a : 0;
    uint32_t grab_inb = rot_sh ? rot_sh : 32;

    while (grab_inb >= 4) {
        mmu_write_vmem<uint32_t>(ea, instr, ppc_state.gpr[reg_s]);
        reg_s++;
        if (reg_s >= 32) {    // wrap around through GPR0
            reg_s = 0;
        }
        ea += 4;
        grab_inb -= 4;
    }

    // handle remaining bytes
    switch (grab_inb) {
    case 1:
        mmu_write_vmem<uint8_t>(ea, instr, ppc_state.gpr[reg_s] >> 24);
        break;
    case 2:
        mmu_write_vmem<uint16_t>(ea, instr, ppc_state.gpr[reg_s] >> 16);
        break;
    case 3:
        mmu_write_vmem<uint16_t>(ea, instr, ppc_state.gpr[reg_s] >> 16);
        mmu_write_vmem<uint8_t>(ea + 2, instr, (ppc_state.gpr[reg_s] >> 8) & 0xFF);
        break;
    default:
        break;
    }
)

OPCODE31 (stswx, 31, 661,
#ifdef CPU_PROFILING
    num_int_stores++;
#endif
    ppc_grab_regssab_stswx(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);
    uint32_t grab_inb = ppc_state.spr[SPR::XER] & 127;

    while (grab_inb >= 4) {
        mmu_write_vmem<uint32_t>(ea, instr, ppc_state.gpr[reg_s]);
        reg_s++;
        if (reg_s >= 32) {    // wrap around through GPR0
            reg_s = 0;
        }
        ea += 4;
        grab_inb -= 4;
    }

    // handle remaining bytes
    switch (grab_inb) {
    case 1:
        mmu_write_vmem<uint8_t>(ea, instr, ppc_state.gpr[reg_s] >> 24);
        break;
    case 2:
        mmu_write_vmem<uint16_t>(ea, instr, ppc_state.gpr[reg_s] >> 16);
        break;
    case 3:
        mmu_write_vmem<uint16_t>(ea, instr, ppc_state.gpr[reg_s] >> 16);
        mmu_write_vmem<uint8_t>(ea + 2, instr, (ppc_state.gpr[reg_s] >> 8) & 0xFF);
        break;
    default:
        break;
    }
)

OPCODE31 (eciwx, 31, 310,
    uint32_t ear_enable = 0x80000000;

    // error if EAR[E] != 1
    if (!(ppc_state.spr[282] && ear_enable)) {
        ppc_exception_handler(Except_Type::EXC_DSI, 0x0);
    }

    ppc_grab_regsdab(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);

    if (ea & 0x3) {
        ppc_alignment_exception(ea, instr);
    }

    uint32_t ppc_result_d = mmu_read_vmem<uint32_t>(ea, instr);

    ppc_store_iresult_reg(reg_d, ppc_result_d);
)

OPCODE31 (ecowx, 31, 438,
    uint32_t ear_enable = 0x80000000;

    // error if EAR[E] != 1
    if (!(ppc_state.spr[282] && ear_enable)) {
        ppc_exception_handler(Except_Type::EXC_DSI, 0x0);
    }

    ppc_grab_regssab(instr);
    uint32_t ea = ppc_result_b + (reg_a ? ppc_result_a : 0);

    if (ea & 0x3) {
        ppc_alignment_exception(ea, instr);
    }

    mmu_write_vmem<uint32_t>(ea, instr, ppc_result_d);
)

// TLB Instructions

OPCODE31 (tlbie, 31, 306,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif

    tlb_flush_entry(ppc_state.gpr[(instr >> 11) & 0x1F]);
)

OPCODE31 (tlbia, 31, 370,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif
    /* placeholder */
)

OPCODE31 (tlbld, 31, 978,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif
    /* placeholder */
)

OPCODE31 (tlbli, 31, 1010,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif
    /* placeholder */
)

OPCODE31 (tlbsync, 31, 566,
#ifdef CPU_PROFILING
    num_supervisor_instrs++;
#endif
    /* placeholder */
)
